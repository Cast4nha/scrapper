import time
import logging
import re
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.firefox.options import Options
from selenium.webdriver.firefox.service import Service
from selenium.common.exceptions import TimeoutException, NoSuchElementException
import os

logger = logging.getLogger(__name__)

class ValSportsScraper:
    def __init__(self):
        """Inicializa o scraper com configura√ß√µes otimizadas"""
        self.driver = None
        self.is_logged_in = False
        self.base_url = "https://www.valsports.net"
        self.session_start_time = None
        self.setup_driver()
    
    def setup_driver(self):
        """Configura o driver do Firefox com configura√ß√µes otimizadas"""
        try:
            # Configura√ß√µes otimizadas para Firefox
            firefox_options = Options()
            
            # Configura√ß√µes para ambiente headless (opcional)
            if os.environ.get('HEADLESS', 'False').lower() == 'true':
                firefox_options.add_argument("--headless")
            
            # Configura√ß√µes de performance
            firefox_options.add_argument("--no-sandbox")
            firefox_options.add_argument("--disable-dev-shm-usage")
            firefox_options.add_argument("--disable-gpu")
            firefox_options.add_argument("--disable-extensions")
            firefox_options.add_argument("--disable-plugins")
            
            # Permitir JavaScript (necess√°rio para o site)
            firefox_options.set_preference("javascript.enabled", True)
            
            # Inicializar driver do Firefox
            self.driver = webdriver.Firefox(options=firefox_options)
            
            # Configurar timeouts otimizados
            self.driver.implicitly_wait(2)  # Reduzido para 2 segundos
            self.driver.set_page_load_timeout(15)  # Reduzido para 15 segundos
            
            # Configurar tamanho da janela
            self.driver.set_window_size(1200, 800)
            
            logger.info("Driver do Firefox configurado com configura√ß√µes otimizadas")
            
        except Exception as e:
            logger.error(f"Erro ao configurar driver: {str(e)}")
            raise
    
    def login(self, username, password):
        """Faz login no sistema ValSports"""
        try:
            logger.info("Iniciando processo de login")
            
            # 1. open on https://www.valsports.net/login
            self.driver.get(f"{self.base_url}/login")
            time.sleep(2)  # Mantido para login est√°vel
            
            # Aguardar carregamento da p√°gina
            wait = WebDriverWait(self.driver, 15)
            
            # 2. click on css=.form-group:nth-child(1) > .form-control
            username_field = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, ".form-group:nth-child(1) > .form-control")))
            username_field.click()
            
            # 3. type on css=.form-group:nth-child(1) > .form-control with value
            username_field.clear()
            username_field.send_keys(username)
            
            # 4. type on css=.form-group:nth-child(2) > .form-control with value
            password_field = self.driver.find_element(By.CSS_SELECTOR, ".form-group:nth-child(2) > .form-control")
            password_field.clear()
            password_field.send_keys(password)
            
            # 5. click on css=.btn-success
            login_button = self.driver.find_element(By.CSS_SELECTOR, ".btn-success")
            login_button.click()
            time.sleep(2)  # Mantido para login est√°vel
            
            # Verificar se o login foi bem-sucedido
            if "betsnow.net" in self.driver.current_url:
                logger.error("Redirecionado para betsnow.net - prote√ß√£o ativada")
                return False
            
            if "login" in self.driver.current_url.lower():
                logger.error("Ainda na p√°gina de login - credenciais inv√°lidas")
                return False
            
            # Verificar se chegou na p√°gina principal
            if self.base_url in self.driver.current_url or "dashboard" in self.driver.current_url.lower():
                logger.info("Login realizado com sucesso")
                self.is_logged_in = True
                return True
            
            logger.warning("Login pode ter falhado - verificando URL atual")
            return False
            
        except TimeoutException:
            logger.error("Timeout durante o login")
            return False
        except Exception as e:
            logger.error(f"Erro durante o login: {str(e)}")
            return False
    
    def scrape_bet_ticket(self, bet_code):
        """Captura dados de um bilhete espec√≠fico usando XPaths e CSS selectors espec√≠ficos"""
        try:
            logger.info(f"üöÄ INICIANDO EXTRA√á√ÉO DO BILHETE: {bet_code}")
            logger.info(f"‚è∞ Timestamp: {time.strftime('%Y-%m-%d %H:%M:%S')}")
            logger.info(f"üåê URL Base: {self.base_url}")

            import os
            if not os.path.exists('logs'):
                os.makedirs('logs')
            if not os.path.exists('downloads'):
                os.makedirs('downloads')

            if not self.is_logged_in:
                logger.warning("N√£o est√° logado, fazendo login primeiro")
                username = os.environ.get('VALSORTS_USERNAME', 'cairovinicius')
                password = os.environ.get('VALSORTS_PASSWORD', '279999')
                if not self.login(username, password):
                    return None

            bet_url = f"{self.base_url}/prebet/{bet_code}"
            logger.info(f"üåê Navegando para: {bet_url}")
            self.driver.get(bet_url)
            
            # Aguardar p√°gina carregar (otimizado agressivamente)
            time.sleep(2)
            
            # Aguardar JavaScript carregar
            wait = WebDriverWait(self.driver, 30)
            
            try:
                # Aguardar container principal do bilhete
                wait.until(EC.presence_of_element_located((By.XPATH, "//main/div[3]/div/div/div")))
                logger.info("‚úÖ Container do bilhete carregado")
            except TimeoutException:
                logger.warning("‚ö†Ô∏è Timeout aguardando container - continuando...")
            
            # Aguardar mais um pouco para garantir (otimizado agressivamente)
            time.sleep(1)
            
            # Salvar debug
            current_url = self.driver.current_url
            logger.info(f"üìç URL atual: {current_url}")
            
            # Salvar screenshot e HTML para debug
            self.driver.save_screenshot(f"scraper_{bet_code}.png")
            
            with open(f"scraper_{bet_code}.html", "w", encoding="utf-8") as f:
                f.write(self.driver.page_source)
            
            # Extrair dados usando XPaths e CSS selectors espec√≠ficos
            bet_data = self._extract_bet_data_with_selectors(bet_code)
            
            return bet_data
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao capturar bilhete: {str(e)}")
            return None
    
    def _extract_bet_data_with_selectors(self, bet_code):
        """Extrai dados usando XPaths e CSS selectors espec√≠ficos"""
        try:
            logger.info("üîç Extraindo dados com selectors espec√≠ficos...")
            
            # Estrutura base dos dados
            bet_data = {
                'bet_code': bet_code,
                'total_games': 0,
                'total_odds': '',
                'possible_prize': '',
                'bettor_name': '',
                'bet_value': '',
                'games': []
            }
            
            # 1. Extrair quantidade de jogos do t√≠tulo "Bilhete15"
            try:
                # Procurar por span com classe "text-theme ml-2" que cont√©m o n√∫mero
                games_count_element = self.driver.find_element(By.CSS_SELECTOR, "span.text-theme.ml-2")
                games_text = games_count_element.text.strip()
                logger.info(f"üìä Texto do contador: {games_text}")
                
                # Extrair n√∫mero do texto
                count_match = re.search(r'(\d+)', games_text)
                if count_match:
                    bet_data['total_games'] = int(count_match.group(1))
                    logger.info(f"üéÆ Total de jogos: {bet_data['total_games']}")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Erro ao extrair contador de jogos: {str(e)}")
            
            # 2. Extrair total das odds
            try:
                total_odds_element = self.driver.find_element(By.XPATH, "//main/div[3]/div/div[2]/div/div/div/div[2]")
                bet_data['total_odds'] = total_odds_element.text.strip()
                logger.info(f"üí∞ Total odds: {bet_data['total_odds']}")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Erro ao extrair total odds: {str(e)}")
            
            # 3. Extrair poss√≠vel pr√™mio "R$ 1.000.000,00"
            try:
                # Procurar por div que cont√©m "R$" e o valor do pr√™mio
                possible_prize_element = self.driver.find_element(By.XPATH, "//div[contains(text(), 'R$')]")
                bet_data['possible_prize'] = possible_prize_element.text.strip()
                logger.info(f"üèÜ Poss√≠vel pr√™mio: {bet_data['possible_prize']}")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Erro ao extrair poss√≠vel pr√™mio: {str(e)}")
            
            # 4. Extrair nome do apostador e valor - usar placeholders espec√≠ficos
            try:
                # Procurar por placeholder "Apostador"
                apostador_inputs = self.driver.find_elements(By.XPATH, "//input[contains(@placeholder, 'Apostador')]")
                if apostador_inputs:
                    bet_data['bettor_name'] = apostador_inputs[0].get_attribute("value")
                    logger.info(f"üë§ Apostador: {bet_data['bettor_name']}")
                
                # Procurar por placeholder "Valor"
                valor_inputs = self.driver.find_elements(By.XPATH, "//input[contains(@placeholder, 'Valor')]")
                if valor_inputs:
                    bet_data['bet_value'] = valor_inputs[0].get_attribute("value")
                    logger.info(f"üíµ Valor: {bet_data['bet_value']}")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Erro ao extrair campos do apostador: {str(e)}")
            
            # 6. Extrair jogos usando seletores corretos baseados no HTML real
            games = self._extract_games_with_real_selectors()
            bet_data['games'] = games
            
            # Atualizar contador se n√£o foi encontrado
            if bet_data['total_games'] == 0:
                bet_data['total_games'] = len(games)
            
            logger.info(f"üéÆ Total de jogos extra√≠dos: {len(games)}")
            
            return bet_data
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao extrair dados: {str(e)}")
            return None
    
    def _extract_games_dynamically(self):
        """Extrai jogos usando itera√ß√£o din√¢mica com .find_elements - vers√£o otimizada"""
        games = []
        
        try:
            logger.info("üéØ Extraindo jogos dinamicamente...")
            
            # Aguardar um pouco para garantir que a p√°gina est√° carregada (otimizado agressivamente)
            time.sleep(1)
            
            # Encontrar todos os elementos .l-item (jogos)
            game_elements = self.driver.find_elements(By.CSS_SELECTOR, ".l-item")
            
            logger.info(f"üîç Encontrados {len(game_elements)} elementos .l-item")
            
            # Processar apenas os primeiros 15 elementos (ou o n√∫mero especificado)
            max_games = min(15, len(game_elements))
            
            for i in range(max_games):
                try:
                    logger.info(f"üéÆ Processando jogo {i+1}...")
                    
                    # Recarregar o elemento para evitar stale reference
                    game_elements = self.driver.find_elements(By.CSS_SELECTOR, ".l-item")
                    if i >= len(game_elements):
                        break
                    
                    game_element = game_elements[i]
                    
                    # Capturar texto completo primeiro
                    full_text = game_element.text
                    logger.info(f"   üìù Texto completo do jogo {i+1}: {full_text[:100]}...")
                    
                    game_data = {
                        'game_number': i+1,
                        'league': '',
                        'home_team': '',
                        'away_team': '',
                        'selection': '',
                        'odds': '',
                        'datetime': ''
                    }
                    
                    # Extrair dados usando regex do texto completo
                    try:
                        # Extrair liga (primeira linha geralmente)
                        lines = full_text.split('\n')
                        if lines:
                            game_data['league'] = lines[0].strip()
                            logger.info(f"   Liga: {game_data['league']}")
                    except Exception as e:
                        logger.warning(f"   ‚ö†Ô∏è Erro ao extrair liga: {str(e)}")
                    
                    try:
                        # Extrair data/hora
                        datetime_match = re.search(r'(\d{2}/\d{2}\s+\d{2}:\d{2})', full_text)
                        if datetime_match:
                            game_data['datetime'] = datetime_match.group(1)
                            logger.info(f"   Data/Hora: {game_data['datetime']}")
                    except Exception as e:
                        logger.warning(f"   ‚ö†Ô∏è Erro ao extrair data/hora: {str(e)}")
                    
                    try:
                        # Extrair times - procurar por padr√µes mais espec√≠ficos
                        # Primeiro, tentar encontrar times ap√≥s a data/hora
                        lines = full_text.split('\n')
                        for j, line in enumerate(lines):
                            # Procurar linha que cont√©m " x " (separador de times)
                            if ' x ' in line and not any(keyword in line.lower() for keyword in ['vencedor:', 'empate', 'odds']):
                                # Limpar a linha de poss√≠veis sufixos
                                clean_line = line.strip()
                                if clean_line.endswith('...'):
                                    clean_line = clean_line[:-3]
                                
                                # Dividir por " x "
                                if ' x ' in clean_line:
                                    parts = clean_line.split(' x ')
                                    if len(parts) == 2:
                                        game_data['home_team'] = parts[0].strip()
                                        game_data['away_team'] = parts[1].strip()
                                        logger.info(f"   Times: {game_data['home_team']} x {game_data['away_team']}")
                                        break
                        
                        # Se n√£o encontrou, tentar regex mais flex√≠vel
                        if not game_data['home_team']:
                            teams_match = re.search(r'([A-Za-z√Ä-√ø\s]+(?:\s+[A-Za-z√Ä-√ø]+)*)\s+x\s+([A-Za-z√Ä-√ø\s]+(?:\s+[A-Za-z√Ä-√ø]+)*)', full_text)
                            if teams_match:
                                game_data['home_team'] = teams_match.group(1).strip()
                                game_data['away_team'] = teams_match.group(2).strip()
                                logger.info(f"   Times (regex): {game_data['home_team']} x {game_data['away_team']}")
                    except Exception as e:
                        logger.warning(f"   ‚ö†Ô∏è Erro ao extrair times: {str(e)}")
                    
                    try:
                        # Extrair sele√ß√£o (padr√£o: "Vencedor: Time" ou "Empate")
                        if 'Vencedor:' in full_text:
                            selection_match = re.search(r'Vencedor:\s*([A-Za-z√Ä-√ø\s]+)', full_text)
                            if selection_match:
                                game_data['selection'] = f"Vencedor: {selection_match.group(1).strip()}"
                        elif 'Empate' in full_text:
                            game_data['selection'] = "Empate"
                        logger.info(f"   Sele√ß√£o: {game_data['selection']}")
                    except Exception as e:
                        logger.warning(f"   ‚ö†Ô∏è Erro ao extrair sele√ß√£o: {str(e)}")
                    
                    try:
                        # Extrair odds (padr√£o: n√∫mero decimal)
                        odds_match = re.search(r'\b(\d+\.\d+)\b', full_text)
                        if odds_match:
                            game_data['odds'] = odds_match.group(1)
                            logger.info(f"   Odds: {game_data['odds']}")
                    except Exception as e:
                        logger.warning(f"   ‚ö†Ô∏è Erro ao extrair odds: {str(e)}")
                    
                    # Validar se tem dados m√≠nimos (odds e sele√ß√£o s√£o obrigat√≥rios)
                    if game_data['odds'] and game_data['selection']:
                        # Formatar dados
                        if game_data['home_team'] and game_data['away_team']:
                            game_data['teams'] = f"{game_data['home_team']} x {game_data['away_team']}"
                        else:
                            game_data['teams'] = "Times n√£o identificados"
                        
                        games.append(game_data)
                        logger.info(f"   ‚úÖ Jogo {i+1} adicionado")
                    else:
                        logger.warning(f"   ‚ö†Ô∏è Jogo {i+1} sem dados suficientes - ignorando")
                
                except Exception as e:
                    logger.error(f"   ‚ùå Erro ao processar jogo {i+1}: {str(e)}")
                    continue
            
            logger.info(f"üéÆ Total de jogos v√°lidos extra√≠dos: {len(games)}")
            
        except Exception as e:
            logger.error(f"‚ùå Erro na extra√ß√£o din√¢mica: {str(e)}")
        
        return games
    
    def _extract_games_with_real_selectors(self):
        """Extrai jogos usando seletores baseados no HTML real fornecido pelo usu√°rio - VERS√ÉO OTIMIZADA PARA M√öLTIPLAS APOSTAS"""
        games = []
        
        try:
            logger.info("üéØ Extraindo jogos com seletores reais (M√öLTIPLAS APOSTAS)...")
            
            # Aguardar menos tempo para carregamento (otimizado agressivamente)
            time.sleep(0.5)
            
            # PRIMEIRO: Tentar extrair do bilhete lateral (bet slip)
            games = self._extract_games_from_bet_slip()
            if games:
                logger.info(f"‚úÖ Extra√≠dos {len(games)} jogos do bilhete lateral")
                return games
            
            # SEGUNDO: Se n√£o encontrou no bilhete lateral, tentar √°rea principal
            logger.info("‚ö†Ô∏è Bilhete lateral n√£o encontrado, tentando √°rea principal...")
            
            # Encontrar todos os elementos .l-item (jogos) que t√™m a classe d-block
            game_elements = self.driver.find_elements(By.CSS_SELECTOR, ".l-item.d-block")
            
            logger.info(f"üîç Encontrados {len(game_elements)} elementos .l-item.d-block")
            
            # Pular os primeiros 10 elementos (s√£o elementos de navega√ß√£o)
            start_index = 10
            valid_games = game_elements[start_index:]
            
            logger.info(f"üéÆ Processando {len(valid_games)} jogos v√°lidos (pulando primeiros {start_index})")
            
            current_game = None
            game_counter = 0
            
            for i, game_element in enumerate(valid_games, 1):
                try:
                    # Capturar texto completo primeiro para valida√ß√£o r√°pida
                    full_text = game_element.text
                    
                    # Verificar se tem dados essenciais antes de processar
                    # Procurar por qualquer tipo de sele√ß√£o (Vencedor, Empate, Ambas equipes marcam, etc.)
                    has_selection = any(keyword in full_text for keyword in ['Vencedor:', 'Empate', 'Ambas equipes marcam', 'Mais de', 'Menos de', 'Gols', 'Corner', 'Cart√£o', 'Jogador'])
                    has_odds = bool(re.search(r'\b\d+\.\d+\b', full_text))
                    
                    if not has_selection or not has_odds:
                        continue
                    
                    # Verificar se √© um novo jogo (tem liga e times) ou uma aposta adicional do mesmo jogo
                    # Verificar se tem liga
                    league_keywords = ['Am√©rica do Sul:', 'CONCACAF:', 'Costa Rica:', 'Venezuela:', 'Inglaterra:', 'Brasil:', 'Espanha:', 'It√°lia:', 'Alemanha:', 'Argentina:', 'Uruguai:', 'Col√¥mbia:', 'Chile:', 'Peru:', 'Equador:', 'Bol√≠via:', 'Paraguai:', 'UEFA:', 'Copa Libertadores', 'Copa Sul Americana', 'Champions League', 'Europa League', 'Premier League', 'La Liga', 'Serie A', 'Bundesliga', 'Brasileir√£o', 'Copa do Brasil', 'Copa do Nordeste', 'Primeira Liga', 'S√©rie A', 'S√©rie B', 'S√©rie C', 'S√©rie D', 'Fran√ßa:', 'Internacional:', 'EUA:', 'FIBA', 'WNBA']
                    has_league = any(keyword in full_text for keyword in league_keywords)
                    
                    # Verificar se tem times
                    exclude_keywords = ['Vencedor:', 'Empate', 'Ambas equipes marcam', 'Mais de', 'Menos de', 'Gols', 'Corner', 'Cart√£o', 'Jogador', 'Odds', 'Data', 'Hora', 'Live']
                    # Verificar se tem times (linha que cont√©m " x " ou linhas 3-4 que n√£o s√£o keywords)
                    lines = full_text.split('\n')
                    has_teams = ' x ' in full_text
                    if not has_teams and len(lines) > 3:
                        for line in lines[2:4]:
                            if line.strip() and not any(keyword in line for keyword in exclude_keywords):
                                has_teams = True
                                break
                    
                    # Verificar se √© um jogo √∫nico (n√£o duplicado)
                    is_unique_game = True
                    if current_game:
                        # Comparar com o jogo atual para ver se √© o mesmo
                        current_teams = current_game.get('teams', '')
                        current_league = current_game.get('league', '')
                        
                        # Extrair times do texto atual
                        current_text_teams = ''
                        current_text_league = ''
                        
                        try:
                            lines = full_text.split('\n')
                            if lines:
                                current_text_league = lines[0].strip()
                            
                            # Extrair times do texto atual
                            for j, line in enumerate(lines):
                                line = line.strip()
                                if (' x ' in line and 
                                    not any(keyword in line.lower() for keyword in ['vencedor:', 'empate', 'odds', 'data', 'hora', 'live']) and
                                    not re.search(r'^\d+\.\d+$', line) and
                                    not re.search(r'^\d{2}/\d{2}', line) and
                                    len(line) > 3):
                                    current_text_teams = line
                                    break
                                elif (j < len(lines) - 1 and 
                                      line and 
                                      not any(keyword in line.lower() for keyword in ['vencedor:', 'empate', 'odds', 'data', 'hora', 'live', 'bundesliga', 's√©rie', 'ligue', 'fiba', 'wnba', 'premier']) and
                                      not re.search(r'^\d+\.\d+$', line) and
                                      not re.search(r'^\d{2}/\d{2}', line) and
                                      len(line) > 2):
                                    next_line = lines[j + 1].strip()
                                    if (next_line and 
                                        not any(keyword in next_line.lower() for keyword in ['vencedor:', 'empate', 'odds', 'data', 'hora', 'live']) and
                                        not re.search(r'^\d+\.\d+$', next_line) and
                                        not re.search(r'^\d{2}/\d{2}', next_line) and
                                        len(next_line) > 2):
                                        current_text_teams = f"{line} x {next_line}"
                                        break
                            
                            # Se tem os mesmos times e liga, √© o mesmo jogo
                            if (current_text_teams and current_text_league and 
                                current_text_teams == current_teams and 
                                current_text_league == current_league):
                                is_unique_game = False
                                
                        except Exception as e:
                            pass
                    
                    if has_league and has_teams and is_unique_game:
                        # √â um novo jogo
                        game_counter += 1
                        logger.info(f"üéÆ Processando NOVO JOGO {game_counter}...")
                        
                        # Extrair dados b√°sicos do jogo
                        current_game = {
                            'game_number': game_counter, 'league': '', 'home_team': '', 'away_team': '',
                            'datetime': '', 'teams': ''
                        }
                        
                        try:
                            # Extrair liga
                            lines = full_text.split('\n')
                            if lines:
                                current_game['league'] = lines[0].strip()
                                logger.info(f"   Liga: {current_game['league']}")
                        except Exception as e: pass
                        
                        try:
                            # Extrair data/hora
                            datetime_match = re.search(r'(\d{2}/\d{2}\s+\d{2}:\d{2})', full_text)
                            if datetime_match:
                                current_game['datetime'] = datetime_match.group(1)
                                logger.info(f"   Data/Hora: {current_game['datetime']}")
                        except Exception as e: pass
                        
                        try:
                            # Extrair times - os times est√£o em linhas consecutivas
                            lines = full_text.split('\n')
                            for j, line in enumerate(lines):
                                line = line.strip()
                                
                                # Procurar por linha que cont√©m " x " (formato antigo)
                                if (' x ' in line and 
                                    not any(keyword in line.lower() for keyword in ['vencedor:', 'empate', 'odds', 'data', 'hora', 'live']) and
                                    not re.search(r'^\d+\.\d+$', line) and
                                    not re.search(r'^\d{2}/\d{2}', line) and
                                    len(line) > 3):
                                    
                                    teams = line.split(' x ')
                                    if len(teams) == 2:
                                        home_team = teams[0].strip()
                                        away_team = teams[1].strip()
                                        
                                        if home_team and away_team and len(home_team) > 1 and len(away_team) > 1:
                                            current_game['home_team'] = home_team
                                            current_game['away_team'] = away_team
                                            current_game['teams'] = f"{home_team} x {away_team}"
                                            logger.info(f"   Times: {current_game['teams']}")
                                            break
                                
                                # Procurar por times em linhas consecutivas (formato novo)
                                elif (j < len(lines) - 1 and 
                                      line and 
                                      not any(keyword in line.lower() for keyword in ['vencedor:', 'empate', 'odds', 'data', 'hora', 'live', 'bundesliga', 's√©rie', 'ligue', 'fiba', 'wnba', 'premier']) and
                                      not re.search(r'^\d+\.\d+$', line) and
                                      not re.search(r'^\d{2}/\d{2}', line) and
                                      len(line) > 2):
                                    
                                    next_line = lines[j + 1].strip()
                                    if (next_line and 
                                        not any(keyword in next_line.lower() for keyword in ['vencedor:', 'empate', 'odds', 'data', 'hora', 'live']) and
                                        not re.search(r'^\d+\.\d+$', next_line) and
                                        not re.search(r'^\d{2}/\d{2}', next_line) and
                                        len(next_line) > 2):
                                        
                                        home_team = line
                                        away_team = next_line
                                        
                                        if home_team and away_team and len(home_team) > 1 and len(away_team) > 1:
                                            current_game['home_team'] = home_team
                                            current_game['away_team'] = away_team
                                            current_game['teams'] = f"{home_team} x {away_team}"
                                            logger.info(f"   Times: {current_game['teams']}")
                                            break
                        except Exception as e: 
                            logger.warning(f"   ‚ö†Ô∏è Erro ao extrair times: {str(e)}")
                    
                    # Extrair TODAS as apostas do elemento
                    if current_game:
                        try:
                            # Procurar por TODAS as sele√ß√µes e odds no texto
                            lines = full_text.split('\n')
                            selections = []
                            odds_list = []
                            
                            # Primeiro, coletar todas as sele√ß√µes e odds
                            for line in lines:
                                line = line.strip()
                                if any(keyword in line for keyword in ['Vencedor:', 'Empate', 'Ambas equipes marcam', 'Mais de', 'Menos de', 'Gols', 'Corner', 'Cart√£o', 'Jogador']):
                                    selections.append(line)
                                elif re.search(r'^\d+\.\d+$', line):
                                    odds_list.append(line)
                            
                            # Criar uma entrada √∫nica para o jogo com todas as apostas
                            if selections and odds_list:
                                # Adicionar o jogo base
                                game_entry = current_game.copy()
                                game_entry['selections'] = []
                                game_entry['odds_list'] = []
                                
                                # Adicionar todas as sele√ß√µes e odds
                                for selection, odds in zip(selections, odds_list):
                                    if selection and odds:
                                        game_entry['selections'].append(selection)
                                        game_entry['odds_list'].append(odds)
                                        logger.info(f"   ‚úÖ Aposta {len(game_entry['selections'])} do Jogo {game_counter}: {selection} - {odds}")
                                
                                games.append(game_entry)
                            else:
                                logger.warning(f"   ‚ö†Ô∏è N√£o conseguiu extrair sele√ß√µes/odds do texto")
                                
                        except Exception as e:
                            logger.warning(f"   ‚ö†Ô∏è Erro ao extrair apostas: {str(e)}")
                
                except Exception as e:
                    logger.error(f"   ‚ùå Erro ao processar jogo {i}: {str(e)}")
                    continue
            
            logger.info(f"üéÆ Total de apostas extra√≠das: {len(games)}")
            
        except Exception as e:
            logger.error(f"‚ùå Erro na extra√ß√£o com seletores reais: {str(e)}")
        
        return games
    
    def _extract_games_from_bet_slip(self):
        """Extrai jogos do bilhete lateral (bet slip) - NOVA FUN√á√ÉO"""
        games = []
        
        try:
            logger.info("üéØ Extraindo jogos do bilhete lateral (bet slip)...")
            
            # Procurar por elementos do bilhete lateral
            # Baseado na imagem, o bilhete est√° no lado direito com "BILHETE 5"
            bet_slip_selectors = [
                # Seletores poss√≠veis para o bilhete lateral
                ".bet-slip",
                ".ticket-sidebar", 
                ".right-sidebar",
                ".col-md-4",
                ".col-lg-4",
                ".col-sm-4",
                "[class*='bet']",
                "[class*='ticket']",
                "[class*='slip']"
            ]
            
            bet_slip_element = None
            for selector in bet_slip_selectors:
                try:
                    elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                    for element in elements:
                        # Verificar se cont√©m dados do bilhete
                        text = element.text
                        if any(keyword in text for keyword in ['BILHETE', 'Total odds', 'Poss√≠vel pr√™mio', 'Felipe', '111,88', '223,76']):
                            bet_slip_element = element
                            logger.info(f"‚úÖ Bilhete lateral encontrado com seletor: {selector}")
                            break
                    if bet_slip_element:
                        break
                except:
                    continue
            
            if not bet_slip_element:
                logger.warning("‚ö†Ô∏è Bilhete lateral n√£o encontrado")
                return games
            
            # Extrair texto completo do bilhete
            bet_slip_text = bet_slip_element.text
            logger.info(f"üìù Texto do bilhete lateral: {bet_slip_text[:200]}...")
            
            # Procurar por jogos no texto do bilhete
            lines = bet_slip_text.split('\n')
            
            # Processar linha por linha de forma mais robusta
            i = 0
            game_counter = 0
            
            while i < len(lines):
                line = lines[i].strip()
                logger.info(f"   Linha {i}: '{line}'")
                
                # Pular linhas vazias ou de cabe√ßalho
                if (not line or 
                    line.startswith('BILHETE') or 
                    'Total odds' in line or 
                    'Poss√≠vel pr√™mio' in line or
                    line.startswith('R$')):
                    i += 1
                    continue
                
                # Procurar por padr√£o de jogo: Liga -> Data/Hora -> Time Casa -> Time Fora -> Sele√ß√£o -> Odds
                if (':' in line and  # Linha cont√©m liga (ex: "Argentina: Nacional B")
                    i + 4 < len(lines)):  # Garantir que h√° linhas suficientes
                    
                    league = line
                    i += 1
                    
                    # Pr√≥xima linha deve ser data/hora
                    if i < len(lines) and re.search(r'\d{2}/\d{2}\s+\d{2}:\d{2}', lines[i]):
                        datetime_str = lines[i].strip()
                        i += 1
                        
                        # Pr√≥ximas duas linhas devem ser times
                        if i + 1 < len(lines):
                            home_team = lines[i].strip()
                            away_team = lines[i + 1].strip()
                            i += 2
                            
                            # Pr√≥xima linha deve ser sele√ß√£o
                            selection = ""
                            if i < len(lines):
                                selection = lines[i].strip()
                                i += 1
                            
                            # Pr√≥xima linha deve ser odds
                            odds = ""
                            if i < len(lines) and re.search(r'^\d+\.\d+$', lines[i]):
                                odds = lines[i].strip()
                                i += 1
                            
                            # Criar jogo se temos dados suficientes
                            if home_team and away_team and selection and odds:
                                game_counter += 1
                                game = {
                                    'game_number': game_counter,
                                    'league': league,
                                    'home_team': home_team,
                                    'away_team': away_team,
                                    'teams': f"{home_team} x {away_team}",
                                    'datetime': datetime_str,
                                    'selection': selection,
                                    'odds': odds
                                }
                                games.append(game)
                                logger.info(f"üéÆ Jogo {game_counter}: {game['teams']}")
                                logger.info(f"   Liga: {league}")
                                logger.info(f"   Data/Hora: {datetime_str}")
                                logger.info(f"   Sele√ß√£o: {selection}")
                                logger.info(f"   Odds: {odds}")
                                logger.info(f"   ‚úÖ Jogo {game_counter} adicionado ao bilhete")
                            else:
                                logger.warning(f"‚ö†Ô∏è Dados insuficientes para jogo na linha {i}")
                        else:
                            logger.warning(f"‚ö†Ô∏è Times n√£o encontrados ap√≥s liga na linha {i}")
                    else:
                        logger.warning(f"‚ö†Ô∏è Data/hora n√£o encontrada ap√≥s liga na linha {i}")
                else:
                    i += 1
            
            logger.info(f"üéÆ Total de jogos extra√≠dos do bilhete lateral: {len(games)}")
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao extrair jogos do bilhete lateral: {str(e)}")
        
        return games
    
    def confirm_bet(self, bet_code):
        """Confirma a aposta no sistema"""
        try:
            if not self.is_logged_in:
                logger.error("‚ùå Usu√°rio n√£o est√° logado")
                return False
            
            logger.info(f"‚úÖ Confirmando aposta: {bet_code}")
            
            # Navegar para o bilhete
            bet_url = f"{self.base_url}/prebet/{bet_code}"
            logger.info(f"üåê Navegando para: {bet_url}")
            self.driver.get(bet_url)
            time.sleep(1)  # Otimizado agressivamente
            
            # Aguardar carregamento
            wait = WebDriverWait(self.driver, 20)
            
            # Verificar se a p√°gina carregou corretamente
            try:
                # Procurar por v√°rios seletores poss√≠veis do bot√£o de confirma√ß√£o
                confirm_button = None
                possible_selectors = [
                    ".btn-group > .text-style",
                    ".btn.text-style",
                    "button[type='button'].btn.text-style",
                    ".btn-group button",
                    "//button[contains(text(), 'Apostar')]",
                    "//a[contains(text(), 'Apostar')]"
                ]
                
                for selector in possible_selectors:
                    try:
                        if selector.startswith("//"):
                            confirm_button = wait.until(EC.element_to_be_clickable((By.XPATH, selector)))
                        else:
                            confirm_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, selector)))
                        logger.info(f"‚úÖ Bot√£o de confirma√ß√£o encontrado com seletor: {selector}")
                        break
                    except:
                        continue
                
                if not confirm_button:
                    logger.error("‚ùå Bot√£o de confirma√ß√£o n√£o encontrado")
                    self.driver.save_screenshot(f"confirm_button_not_found_{bet_code}.png")
                    return False
                
                # Scroll para o elemento se necess√°rio
                self.driver.execute_script("arguments[0].scrollIntoView(true);", confirm_button)
                time.sleep(0.5)  # Otimizado agressivamente
                
                # Tentar clicar
                try:
                    confirm_button.click()
                    logger.info("‚úÖ Clique no bot√£o de confirma√ß√£o realizado")
                except Exception as click_error:
                    logger.warning(f"‚ö†Ô∏è Clique normal falhou, tentando JavaScript: {click_error}")
                    self.driver.execute_script("arguments[0].click();", confirm_button)
                    logger.info("‚úÖ Clique via JavaScript realizado")
                
                time.sleep(2)  # Otimizado agressivamente
                
                # Procurar pelo bot√£o "Sim" para confirmar
                yes_button = None
                yes_selectors = [
                    "//a[contains(text(),'Sim')]",
                    "//button[contains(text(),'Sim')]", 
                    "//a[contains(text(),'SIM')]",
                    "//button[contains(text(),'SIM')]",
                    ".btn-success",
                    ".btn[data-dismiss='modal']",
                    "//button[contains(@class, 'btn-success')]",
                    "//a[contains(@class, 'btn-success')]"
                ]
                
                for selector in yes_selectors:
                    try:
                        yes_button = wait.until(EC.element_to_be_clickable((By.XPATH, selector)))
                        logger.info(f"‚úÖ Bot√£o 'Sim' encontrado com seletor: {selector}")
                        break
                    except:
                        continue
                
                # Se n√£o encontrou, procurar por pop-ups de mudan√ßa de odds
                if not yes_button:
                    logger.info("üîç Procurando por pop-ups de mudan√ßa de odds...")
                    try:
                        # Seletores espec√≠ficos para o pop-up de mudan√ßa de odds
                        popup_selectors = [
                            # Seletores espec√≠ficos fornecidos pelo usu√°rio
                            "/html/body/div[3]/div/div[2]/div[3]/a[2]",  # XPath espec√≠fico
                            "a.v-dialog-btn:nth-child(2)",  # CSS espec√≠fico
                            # Seletores gen√©ricos para pop-ups
                            "//div[contains(text(), 'Deseja continuar?')]//following-sibling::*//button[contains(text(), 'SIM')]",
                            "//div[contains(text(), 'Deseja continuar?')]//following-sibling::*//a[contains(text(), 'SIM')]",
                            "//div[contains(text(), 'Mudan√ßa de pr√™mio')]//following-sibling::*//button[contains(text(), 'SIM')]",
                            "//div[contains(text(), 'Mudan√ßa de pr√™mio')]//following-sibling::*//a[contains(text(), 'SIM')]",
                            "//button[contains(text(), 'SIM') and contains(@class, 'btn-success')]",
                            "//a[contains(text(), 'SIM') and contains(@class, 'btn-success')]",
                            "//button[contains(text(), 'SIM')]",
                            "//a[contains(text(), 'SIM')]",
                            "//button[contains(text(), 'Sim')]",
                            "//a[contains(text(), 'Sim')]"
                        ]
                        
                        for selector in popup_selectors:
                            try:
                                if selector.startswith("/"):
                                    # XPath
                                    yes_button = wait.until(EC.element_to_be_clickable((By.XPATH, selector)))
                                else:
                                    # CSS
                                    yes_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, selector)))
                                logger.info(f"‚úÖ Bot√£o 'SIM' do pop-up encontrado com seletor: {selector}")
                                break
                            except:
                                continue
                        
                        # Se ainda n√£o encontrou, tentar procurar por qualquer bot√£o verde
                        if not yes_button:
                            logger.info("üîç Procurando por qualquer bot√£o verde...")
                            green_button_selectors = [
                                "//button[contains(@class, 'btn-success')]",
                                "//a[contains(@class, 'btn-success')]",
                                "//button[contains(@style, 'green')]",
                                "//a[contains(@style, 'green')]"
                            ]
                            
                            for selector in green_button_selectors:
                                try:
                                    buttons = self.driver.find_elements(By.XPATH, selector)
                                    for button in buttons:
                                        if button.is_displayed() and button.is_enabled():
                                            yes_button = button
                                            logger.info(f"‚úÖ Bot√£o verde encontrado com seletor: {selector}")
                                            break
                                    if yes_button:
                                        break
                                except:
                                    continue
                    except Exception as e:
                        logger.warning(f"‚ö†Ô∏è Erro ao procurar pop-up de mudan√ßa de odds: {str(e)}")
                
                if yes_button:
                    # Scroll para o elemento se necess√°rio
                    self.driver.execute_script("arguments[0].scrollIntoView(true);", yes_button)
                    time.sleep(0.5)  # Otimizado agressivamente
                    
                    try:
                        yes_button.click()
                        logger.info("‚úÖ Clique no bot√£o 'Sim' realizado")
                    except Exception as click_error:
                        logger.warning(f"‚ö†Ô∏è Clique normal no 'Sim' falhou, tentando JavaScript: {click_error}")
                        self.driver.execute_script("arguments[0].click();", yes_button)
                        logger.info("‚úÖ Clique via JavaScript no 'Sim' realizado")
                    
                    time.sleep(1)  # Aguardar para poss√≠vel segundo pop-up (otimizado agressivamente)
                    
                    # Verificar se apareceu pop-up de mudan√ßa de odds
                    logger.info("üîç Verificando se apareceu pop-up de mudan√ßa de odds...")
                    try:
                        # Seletores espec√≠ficos para pop-up de mudan√ßa de odds
                        odds_popup_selectors = [
                            "/html/body/div[3]/div/div[2]/div[3]/a[2]",  # XPath espec√≠fico
                            "a.v-dialog-btn:nth-child(2)",  # CSS espec√≠fico
                            "//div[contains(text(), 'Mudan√ßa de pr√™mio')]//following-sibling::*//a[contains(text(), 'SIM')]",
                            "//div[contains(text(), 'Deseja continuar?')]//following-sibling::*//a[contains(text(), 'SIM')]"
                        ]
                        
                        odds_yes_button = None
                        for selector in odds_popup_selectors:
                            try:
                                if selector.startswith("/"):
                                    odds_yes_button = wait.until(EC.element_to_be_clickable((By.XPATH, selector)))
                                else:
                                    odds_yes_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, selector)))
                                logger.info(f"‚úÖ Pop-up de mudan√ßa de odds encontrado: {selector}")
                                break
                            except:
                                continue
                        
                        if odds_yes_button:
                            logger.info("üñ±Ô∏è Clicando no 'SIM' do pop-up de mudan√ßa de odds...")
                            try:
                                odds_yes_button.click()
                                logger.info("‚úÖ Clique no 'SIM' do pop-up de mudan√ßa de odds realizado")
                            except Exception as click_error:
                                logger.warning(f"‚ö†Ô∏è Clique normal falhou, tentando JavaScript: {click_error}")
                                self.driver.execute_script("arguments[0].click();", odds_yes_button)
                                logger.info("‚úÖ Clique via JavaScript no 'SIM' do pop-up realizado")
                            time.sleep(1)  # Otimizado agressivamente
                        else:
                            logger.info("‚ÑπÔ∏è Nenhum pop-up de mudan√ßa de odds encontrado")
                    except Exception as e:
                        logger.warning(f"‚ö†Ô∏è Erro ao verificar pop-up de mudan√ßa de odds: {str(e)}")
                    
                    time.sleep(1)  # Aguardar final (otimizado agressivamente)
                    
                    # Verificar se houve confirma√ß√£o (procurar por mensagem de sucesso ou mudan√ßa na URL)
                    current_url = self.driver.current_url
                    logger.info(f"üìç URL atual ap√≥s confirma√ß√£o: {current_url}")
                    
                    # Se foi redirecionado para /bets, confirma√ß√£o foi bem-sucedida
                    if "/bets" in current_url:
                        logger.info("‚úÖ Redirecionado para p√°gina de apostas - confirma√ß√£o bem-sucedida")
                        return True
                    
                    # Se foi redirecionado para home, verificar se realmente foi confirmado
                    if current_url == f"{self.base_url}/" or current_url == self.base_url:
                        logger.info("üîç Verificando se a aposta foi realmente confirmada...")
                        
                        # Navegar para a p√°gina de apostas para verificar
                        self.driver.get(f"{self.base_url}/bets")
                        time.sleep(1)  # Otimizado agressivamente
                        
                        # Verificar se h√° apostas abertas
                        try:
                            # Procurar por mensagem "Nenhuma aposta encontrada"
                            no_bets_element = self.driver.find_element(By.XPATH, "//*[contains(text(), 'Nenhuma aposta encontrada')]")
                            if no_bets_element:
                                logger.error("‚ùå Nenhuma aposta encontrada - confirma√ß√£o falhou")
                                self.driver.save_screenshot(f"no_bets_found_{bet_code}.png")
                                return False
                        except:
                            # Se n√£o encontrou a mensagem, pode ter apostas
                            logger.info("‚úÖ Apostas encontradas - confirma√ß√£o bem-sucedida")
                            return True
                    
                    # Se ainda est√° na p√°gina do bilhete, confirma√ß√£o falhou
                    if f"/prebet/{bet_code}" in current_url:
                        logger.error("‚ùå Ainda na p√°gina do bilhete - confirma√ß√£o falhou")
                        self.driver.save_screenshot(f"confirmation_failed_{bet_code}.png")
                        return False
                    
                    # Para qualquer outro caso, assumir sucesso
                    logger.info("‚úÖ Confirma√ß√£o conclu√≠da com sucesso")
                    return True
                else:
                    logger.warning("‚ö†Ô∏è Bot√£o 'Sim' n√£o encontrado")
                    # Salvar screenshot para debug
                    self.driver.save_screenshot(f"confirm_final_{bet_code}.png")
                    return False
                
                # Se chegou at√© aqui, verificar se realmente foi confirmado
                logger.info("‚úÖ Processo de confirma√ß√£o conclu√≠do - verificando resultado")
                
            except TimeoutException:
                logger.error("‚ùå Timeout - elementos n√£o encontrados")
                self.driver.save_screenshot(f"timeout_error_{bet_code}.png")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erro ao confirmar aposta: {str(e)}")
            self.driver.save_screenshot(f"error_{bet_code}.png")
            return False
    
    def close(self):
        """Fecha o driver"""
        try:
            if self.driver:
                self.driver.quit()
                logger.info("üîí Driver fechado")
        except:
            pass
